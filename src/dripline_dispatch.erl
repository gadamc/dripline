%% @doc The dripline_dispatch module exports a single function, 
%%		dispatch/1, whose job it is to take documents from the
%%		couchdb changes feed (as processed by the cmd and conf
%%		monitors) and dispatch the processed result to the 
%%		appropriate actors.  The result is then sent back to the
%%		database.
%% @version 0.1a
%% @todo This module should very probably be a gen_fsm.
%% @author Jared Kofron <jared.kofron@gmail.com>
-module(dripline_dispatch).

%%%%%%%%%%%%%%%%%%%%%%
%%% Module exports %%%
%%%%%%%%%%%%%%%%%%%%%%
-export([dispatch/1]).

%%%%%%%%%%%%%%%%%%%%%
%%% API Functions %%%
%%%%%%%%%%%%%%%%%%%%%

%%---------------------------------------------------------------------%%
%% @doc dispatch/1 receives updates from the changes feed via the 
%% 		changes monitors.  it extracts the documents from the change data
%%		and passes them down for further processing.
%% @end
%%---------------------------------------------------------------------%%
-spec dispatch(ejson:ejson_object()) -> {ok | {error, term()}}.
dispatch(CouchDBChangeLine) ->
	Doc = proplists:get_value(<<"doc">>,CouchDBChangeLine),
	dispatch_doc(Doc).

%%---------------------------------------------------------------------%%
%% @doc dispatch_doc/1 is called directly by dispatch/1 and processes 
%% 		only the document portion of the change line.  the document is 
%%		then passed to another function depending on its 'type'.
%% @end
%%---------------------------------------------------------------------%%
-spec dispatch_doc(ejson:ejson_object()) -> {ok | {error, term()}}.
dispatch_doc(CmdDoc) ->
	Type = couchbeam_doc:get_value(<<"type">>,CmdDoc),
	case Type of
		<<"query">> ->
			dispatch_query(CmdDoc);
		_ ->
			{error,{unknown_cmd_type,Type}}
	end.

%%---------------------------------------------------------------------%%
%% @doc dispatch_query/1 is called by dispatch_doc/1 when the document
%%		received is of 'query' type.  
%% @end
%%---------------------------------------------------------------------%%
-spec dispatch_query(ejson:ejson_object()) -> {ok | {error, term()}}.
dispatch_query(CmdDoc) ->
	{QString} = couchbeam_doc:get_value(<<"query">>,CmdDoc),
	QStringE = fetch_channel_info(QString),
	D = proplists:get_value(<<"read">>,QStringE),
	Call = dict:fetch(read,D),
	Args = dict:fetch(locator,D),
	Result = Call(Args),
	ServConn = dripline_conn_mgr:get(),
	{ok, Db} = couchbeam:open_db(ServConn,"dripline_cmd"),
	update_doc(Db,Result,CmdDoc).

%%---------------------------------------------------------------------%%
%% @doc update_doc/3 is the function that is responsible for posting the
%% 		response to a message to the couch database.  It is agnostic as 
%%		to the query type, as the database argument is generated by the
%%		caller, and all the functionality contained within is generic.
%% @end
%%---------------------------------------------------------------------%%
-spec update_doc(couchbeam:db(),binary(),ejson:ejson_object()) -> 
		{ok | {error,term()}}.
update_doc(Db, CmdResult, CmdDoc) ->
	UpDoc = couchbeam_doc:set_value(<<"result">>,CmdResult,CmdDoc),
	NewRev = couchbeam_doc:get_value(<<"_rev">>,CmdDoc),
	Id = couchbeam_doc:get_value(<<"_id">>,CmdDoc),
	NewRevNo = strip_rev_no(NewRev) + 1,
	spawn(fun() -> dripline_cmd_mon:notify(Id,NewRevNo) end),
	case couchbeam:save_doc(Db,UpDoc) of
		{ok, _} ->
			ok;
		{error, _Error}=Err ->
			Err
	end.

%%---------------------------------------------------------------------%%
%% @doc strip_rev_no/1 takes a binary "_rev" tag and strips the revision
%% 		sequence number.  this is very useful for notifying the monitor
%%		that a sequence number is about to be changed by e.g. us.
%% @end
%%---------------------------------------------------------------------%%
-spec strip_rev_no(binary()) -> integer().
strip_rev_no(BinRev) ->
	[NS,_] = string:tokens(binary_to_list(BinRev),"-"),
	{N,[]} = string:to_integer(NS),
	N.

%%---------------------------------------------------------------------%%
%% @doc fetch_channel_info/1 takes a string from a 'query' field and 
%%		turns it into executable code by pulling channel data from the
%%		dripline_conf_mgr and performing a series of dict merges.
%% @end
%%---------------------------------------------------------------------%%
-spec fetch_channel_info(ejson:ejson_object()) -> [{binary(),[dict()]}].
fetch_channel_info(QueryString) ->
	QS1 = lists:keymap(fun(X) -> 
			lists:map(fun(Y) -> 
				dripline_conf_mgr:lookup(channel,Y) end,X)
	end, 2, QueryString),
	merge_commands(QS1).

%%---------------------------------------------------------------------%%
%% @doc merge_commands takes a list of channel query data and merges it 
%% 		in an intelligent way such that requests made to the same 
%%		instrument are turned into a single request to a single 
%%		instrument.
%% @end
%%---------------------------------------------------------------------%%
-spec merge_commands([{binary(),[dict()]}]) -> [{binary(),[dict()]}].
merge_commands(CommandList) ->
	merge_commands(CommandList,[]).
merge_commands([],Acc) ->
	Acc;
merge_commands([{Cmd,DictList}|T],Acc) ->
	MergedDicts = merge_dicts(DictList),
	merge_commands(T,[{Cmd,MergedDicts}|Acc]).

%%---------------------------------------------------------------------%%
%% @doc merge_dicts/1 takes a list of dicts and returns a single dict via
%%		recursive calls to dict:merge.
%% @end
%%---------------------------------------------------------------------%%
-spec merge_dicts([dict()]) -> dict().
merge_dicts([]) ->
	dict:new();
merge_dicts(List) ->
	merge_dicts(List,dict:new()).
merge_dicts([],Acc) ->
	Acc;
merge_dicts([D|T],Acc) ->
	MD = dict:merge(fun(K,V1,V2) -> merge_dict_keys(K,V1,V2) end,D,Acc),
	merge_dicts(T,MD).

%%---------------------------------------------------------------------%%
%% @doc merge_dict_keys/3 is the merge function that is used by 
%%		merge_dicts/1.  it conforms to the spec that dict:merge wants.
%%		in particular, for matching keys but different values, it turns
%%		the values into a list (or if one is already a list, it appends
%%		to the head of that list).  for matching keys and the same value,
%%		it chucks one of the values out and only takes one.
%% @end
%%---------------------------------------------------------------------%%
-spec merge_dict_keys(term(),term(),term()) -> term() | [term()].
merge_dict_keys(_K,V1,V1) ->
	V1;
merge_dict_keys(_K,V1,V2) when is_list(V1) ->
	[V2|V1];
merge_dict_keys(_K,V1,V2) when is_list(V2) ->
	[V1|V2];
merge_dict_keys(_K,V1,V2) ->
	[V1,V2].