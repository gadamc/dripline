%% @doc The dripline_dispatch module exports a single function, 
%%		dispatch/1, whose job it is to take documents from the
%%		couchdb changes feed (as processed by the cmd and conf
%%		monitors) and dispatch the processed result to the 
%%		appropriate actors.  The result is then sent back to the
%%		database.
%% @version 0.1a
%% @author Jared Kofron <jared.kofron@gmail.com>
-module(dripline_dispatch).
-behavior(gen_fsm).

%%%%%%%%%%%%%%%%%%%%
%%% Exported API %%%
%%%%%%%%%%%%%%%%%%%%
-export([dispatch/1]).

%%%%%%%%%%%%%%%%%%%
%%% gen_fsm API %%%
%%%%%%%%%%%%%%%%%%%
-export([start_link/0]).
-export([init/1, handle_event/3, handle_sync_event/4, handle_info/3, 
		terminate/3, code_change/4]).

%%%%%%%%%%%%%%%%%%%%%%
%%% gen_fsm states %%%
%%%%%%%%%%%%%%%%%%%%%%
-export([waiting/2,sending/2]).
-export([resolve_type/2,resolve_function/2,resolve_module/2,resolve_args/2]).
-export([finishing/2]).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% internal state records %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-record(state,{cur_doc,call}).

%%%%%%%%%%%%%%
%%% Macros %%%
%%%%%%%%%%%%%%
-define(NOW,0).

%%%%%%%%%%%%%
%%% Types %%%
%%%%%%%%%%%%%
-type call() :: {atom(),atom(),[term()]}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Exported API Definitions %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%---------------------------------------------------------------------%%
%% @doc dispatch/1 receives updates from the changes feed via the 
%% 		changes monitors.  it extracts the documents from the change data
%%		and fires them off to the fsm for processing.
%% @end
%%---------------------------------------------------------------------%%
-spec dispatch(ejson:ejson_object()) -> {ok | {error, term()}}.
dispatch(CouchDBChangeLine) ->
	Doc = proplists:get_value(<<"doc">>,CouchDBChangeLine),
	gen_fsm:send_all_state_event(?MODULE,{process,Doc}).

%%---------------------------------------------------------------------%%
%% @doc dispatch_query/1 is called by dispatch_doc/1 when the document
%%		received is of 'query' type.  
%% @end
%%---------------------------------------------------------------------%%
-spec dispatch_query(ejson:ejson_object()) -> {ok | {error, term()}}.
dispatch_query(CmdDoc) ->
	{QString} = couchbeam_doc:get_value(<<"query">>,CmdDoc),
	QStringE = fetch_channel_info(QString),
	D = proplists:get_value(<<"read">>,QStringE),
	Call = dict:fetch(read,D),
	Args = dict:fetch(locator,D),
	Result = Call(Args),
	ServConn = dripline_conn_mgr:get(),
	{ok, Db} = couchbeam:open_db(ServConn,"dripline_cmd"),
	update_doc(Db,Result,CmdDoc).

%%---------------------------------------------------------------------%%
%% @doc update_doc/3 is the function that is responsible for posting the
%% 		response to a message to the couch database.  It is agnostic as 
%%		to the query type, as the database argument is generated by the
%%		caller, and all the functionality contained within is generic.
%% @end
%%---------------------------------------------------------------------%%
-spec update_doc(couchbeam:db(),binary(),ejson:ejson_object()) -> 
		{ok | {error,term()}}.
update_doc(Db, CmdResult, CmdDoc) ->
	UpDoc = couchbeam_doc:set_value(<<"result">>,CmdResult,CmdDoc),
	NewRev = couchbeam_doc:get_value(<<"_rev">>,CmdDoc),
	Id = couchbeam_doc:get_value(<<"_id">>,CmdDoc),
	NewRevNo = strip_rev_no(NewRev) + 1,
	spawn(fun() -> dripline_cmd_mon:notify(Id,NewRevNo) end),
	case couchbeam:save_doc(Db,UpDoc) of
		{ok, _} ->
			ok;
		{error, _Error}=Err ->
			Err
	end.

%%---------------------------------------------------------------------%%
%% @doc strip_rev_no/1 takes a binary "_rev" tag and strips the revision
%% 		sequence number.  this is very useful for notifying the monitor
%%		that a sequence number is about to be changed by e.g. us.
%% @end
%%---------------------------------------------------------------------%%
-spec strip_rev_no(binary()) -> integer().
strip_rev_no(BinRev) ->
	[NS,_] = string:tokens(binary_to_list(BinRev),"-"),
	{N,[]} = string:to_integer(NS),
	N.

%%---------------------------------------------------------------------%%
%% @doc fetch_channel_info/1 takes a string from a 'query' field and 
%%		turns it into executable code by pulling channel data from the
%%		dripline_conf_mgr and performing a series of dict merges.
%% @end
%%---------------------------------------------------------------------%%
-spec fetch_channel_info(ejson:ejson_object()) -> [{binary(),[dict()]}].
fetch_channel_info(QueryString) ->
	QS1 = lists:keymap(fun(X) -> 
			lists:map(fun(Y) -> 
				dripline_conf_mgr:lookup(channel,Y) end,X)
	end, 2, QueryString),
	merge_commands(QS1).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% gen_fsm API and callback definitions %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
start_link() ->
	gen_fsm:start_link({local,?MODULE},?MODULE,[],[]).

init([]) ->
	InitialState = #state{call = new_call()},
	{ok, waiting, InitialState, 0}.

handle_event({process, Doc}, waiting, StateData) ->
	NewStateData = StateData#state{cur_doc = Doc},
	{next_state, resolve_type, NewStateData, ?NOW}.

handle_sync_event(_Ev, _F, waiting, SData) ->
	{reply, ok, waiting, SData}.

handle_info(_Info, waiting, StateData) ->
	{next_state, waiting, StateData}.

terminate(_Reason, _StateName, _StateData) ->
	ok.

code_change(_Vsn, StateName, StateData, _Extra) ->
	{ok, StateName, StateData}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% gen_fsm state definitions %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
waiting(_Event,StateData) ->
	{next_state, waiting, StateData}.

resolve_type(timeout,#state{cur_doc=Doc}=StateData) ->
	NextState = case couchbeam_doc:get_value(<<"type">>,Doc) of
		<<"command">> -> 
			resolve_module;
		<<"system">> ->
			finishing
	end,
	{next_state, NextState, StateData, ?NOW}.

resolve_module(timeout,#state{cur_doc=Doc,call=C}=StateData) ->
	Cmd = couchbeam_doc:get_value(<<"command">>,Doc),
	ChName = couchbeam_doc:get_value(<<"channel">>,Cmd),
	Module = dripline_conf_mgr:lookup(module,ChName),
	NextStateData = StateData#state{call=set_call(m,Module,C)},
	{next_state,resolve_function,NextStateData,?NOW}.

resolve_function(timeout,#state{cur_doc=Doc,call=C}=StateData) ->
	Cmd = couchbeam_doc:get_value(<<"command">>,Doc),
	F = case couchbeam_doc:get_value(<<"do">>,Cmd) of
				<<"get">> ->
					read;
				<<"set">> ->
					write
	end,
	NextStateData = StateData#state{call=set_call(f,F,C)},
	{next_state,resolve_args,NextStateData,?NOW}.

resolve_args(timeout,#state{cur_doc=Doc,call=C}=StateData) ->
	Cmd = couchbeam_doc:get_value(<<"command">>,Doc),
	ChName = couchbeam_doc:get_value(<<"channel">>,Cmd),
	Instr = dripline_conf_mgr:lookup(instrument_id,ChName),
	Locator = dripline_conf_mgr:lookup(locator,ChName),
	BaseArgs = [Instr,Locator],
	AllArgs = case get_call(f,C) of
		read ->
			BaseArgs;
		write ->
			V = couchbeam_doc:get_value(<<"value">>,Cmd),
			BaseArgs ++ [V]
	end,
	NewCall = set_call(a,AllArgs,C),
	NextStateData = StateData#state{call=NewCall},
	{next_state,sending,NextStateData,?NOW}.

sending(timeout,#state{call=C}=StateData) ->
	io:format("~p~n",[C]),
	{next_state,finishing,StateData,?NOW}.

finishing(timeout,StateData) ->
	NextStateData = StateData#state{cur_doc=none,call=new_call()},
	{next_state,waiting,NextStateData}.

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Internal Functions %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

%%---------------------------------------------------------------------%%
%% @doc merge_commands takes a list of channel query data and merges it 
%% 		in an intelligent way such that requests made to the same 
%%		instrument are turned into a single request to a single 
%%		instrument.
%% @end
%%---------------------------------------------------------------------%%
-spec merge_commands([{binary(),[dict()]}]) -> [{binary(),[dict()]}].
merge_commands(CommandList) ->
	merge_commands(CommandList,[]).
merge_commands([],Acc) ->
	Acc;
merge_commands([{Cmd,DictList}|T],Acc) ->
	MergedDicts = merge_dicts(DictList),
	merge_commands(T,[{Cmd,MergedDicts}|Acc]).

%%---------------------------------------------------------------------%%
%% @doc merge_dicts/1 takes a list of dicts and returns a single dict via
%%		recursive calls to dict:merge.
%% @end
%%---------------------------------------------------------------------%%
-spec merge_dicts([dict()]) -> dict().
merge_dicts([]) ->
	dict:new();
merge_dicts(List) ->
	merge_dicts(List,dict:new()).
merge_dicts([],Acc) ->
	Acc;
merge_dicts([D|T],Acc) ->
	MD = dict:merge(fun(K,V1,V2) -> merge_dict_keys(K,V1,V2) end,D,Acc),
	merge_dicts(T,MD).

%%---------------------------------------------------------------------%%
%% @doc merge_dict_keys/3 is the merge function that is used by 
%%		merge_dicts/1.  it conforms to the spec that dict:merge wants.
%%		in particular, for matching keys but different values, it turns
%%		the values into a list (or if one is already a list, it appends
%%		to the head of that list).  for matching keys and the same value,
%%		it chucks one of the values out and only takes one.
%% @end
%%---------------------------------------------------------------------%%
-spec merge_dict_keys(term(),term(),term()) -> term() | [term()].
merge_dict_keys(_K,V1,V1) ->
	V1;
merge_dict_keys(_K,V1,V2) when is_list(V1) ->
	[V2|V1];
merge_dict_keys(_K,V1,V2) when is_list(V2) ->
	[V1|V2];
merge_dict_keys(_K,V1,V2) ->
	[V1,V2].

%%---------------------------------------------------------------------%%
%% @doc new_call/0 generates a raw call.
%%---------------------------------------------------------------------%%
-spec new_call() -> call().
new_call() ->
	{none,none,[]}.

%%---------------------------------------------------------------------%%
%% @doc get_call/2 is a way to inspect MFA values.
%%---------------------------------------------------------------------%%
-spec get_call(atom(),call()) -> call().
get_call(m,{A,_,_}) ->
	A;
get_call(f,{_,B,_}) ->
	B;
get_call(a,{_,_,C}) ->
	C.

%%---------------------------------------------------------------------%%
%% @doc set_call/3 is a way to manipulate the mfa tuple stored by the 
%%		fsm.  this is just to abstract it away in case we change it in 
%%		the future.
%%---------------------------------------------------------------------%%
-spec set_call(atom(),term(),call()) -> call().
set_call(m,M,{_,B,C}) ->
	{M,B,C};
set_call(f,F,{A,_,C}) ->
	{A,F,C};
set_call(a,Ar,{A,B,_}) ->
	{A,B,Ar}.